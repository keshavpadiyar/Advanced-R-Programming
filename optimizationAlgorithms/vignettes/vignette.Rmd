---
title: "optimization Algorithms"
author: "Siddahrth Saminathan"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r , include = FALSE}

knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## What is Knapsack Problem?

The knapsack problem is a optimization , maximization problem where a set of elements V and W are given. Each element V has a value or a profit and W is the total capacity of the bag that can hold all the items. For instance take vegetables. Then V stands for the vegetables with its weight in (kg) and W is the total amount of weight you can carry. The goal is to fill the bag with the most valuable items within the capacity of the bag.

By implementing the alogrithm using different methods we try to understnad how time and space complexity plays a crucial rold in writing Fast R codes. We also try to optimize our brute force alogorithm using parellelism

The following data is used as sample
```{r setup}
library("optimizationAlgorithms")

set.seed(42)
n <- 2000
knapsack_objects <-
data.frame(
w=sample(1:4000, size = n, replace = TRUE),
v=runif(n = n, 0, 10000)
)
```


In this package we demonstrate the solution for knapsack problem using three different methods namely:

## 1.Brute Force Method

The brute force method is the slowest method since in traverses for every element and hen returns the maximum value for the given capacity.
This method runs at O(2^n) evaluating the 2^n possible combinations.
example:

```{r}
brute_force_knapsack(x = knapsack_objects[1:8,], W = 3500)
```
Now lets Check the time taken to run the fucntion

```{r}
system.time(brute_force_knapsack(x = knapsack_objects[1:8,], W = 3500))
```

The time taken to run n=16 samples is :
```{r}
system.time(brute_force_knapsack(x = knapsack_objects[1:16,], W = 3500))
```
As you can see there is a significant increase in execution time as n increase

## 2.Dynamic Programming

This approach runs at O(Wn) time complexity. This yeilds the exact output and discrete values as input. This methods works faster than the brute force approach.

```{r}
system.time(knapsack_dynamic(x = knapsack_objects[1:8,], W = 3500))
```
The time taken to yeild result for n=500 samples is :

```{r}
system.time(knapsack_dynamic(x = knapsack_objects[1:500,], W = 3500))


```

It clearly shows how fast this approach is compared to Brute force. Note that we calculated the result for 500 obseravations compared to only 16 in teh brute force approach.

## 3.Greedy Heuristic Method

This approach gives a 50% accuarte maximum values while considerably minimizing the time complexity to O(nlon(n)).
 

```{r}
system.time(greedy_knapsack(x = knapsack_objects[1:800,], W = 3500))
``` 
```{r}
system.time(greedy_knapsack(x = knapsack_objects[1:1000000,], W = 3500))
``` 

This method  proves to be the fastest among others while giving only 50% accuarate maximum values.This method is versatile in calculating approximate values for large samples of data. 
 
.


